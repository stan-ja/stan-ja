
## 26. ステートメント (文)

<!--
statement を "文" とした場合、以降説明にて何を指しているか
読み取りにくくなるためカタカナとした
-->

Stan プログラムのブロック ( 28章を参照 ) は、変数の宣言とステートメント (文)
から成り立っています。BUGS と違って、Stan プログラム中の宣言とステートメントはそれらが
記載された順序で実行されます。変数は、それが参照される前に何らかの値 (と何らかのデータ型の宣言)
によって定義されていなければいけません --- そうでない場合、実行結果は未定義となります。

BUGS と同じく、Stan の基本的なステートメントには代入とサンプリングの 2 種類があります。
また、いくつかのステートメントは 連続した処理や for-each ループとしてグループに
できます。加えて、Stan では ブロック内でのローカル変数の宣言や、セミコロンのみからなる
空のステートメントも許容されています。

## 26.1. 代入ステートメント

代入ステートメントは変数と式からなります。変数は多次元で、変数に対するインデックスの情報を
含むこともあります。代入ステートメントが実行されると、ステートメントの右辺にある式が評価され、
その結果が左辺の変数 (インデックスがある場合は指定された箇所) に代入されます。
簡単な代入の例は以下のようなものです。

<!--
以降も原文には都度 (indexed) の記載があるが、日本語で簡潔に記載できる語がないため省略
-->

```
n <- 0;
```

このステートメントが実行されると、式 ``0``、つまり 整数のゼロが評価され、変数 ``n`` に代入
されます。代入が成立するためには、右辺の式のデータ型と左辺の変数のデータ型は一致していな
ければなりません。上の例では、``0`` という式は ``int`` 型になるため、
変数 ``n`` は ``int`` 型もしくは ``real`` 型で宣言されていなければなりません。
変数が ``real`` 型で宣言されている場合は、整数のゼロは浮動小数点のゼロに変換されて
変数に代入されます。ステートメントが実行された後は、変数 ``n`` はゼロ (変数のデータ型に応じて整数
もしくは浮動小数点) という値を持ちます。

文法的には、すべての代入ステートメントはセミコロンで終わっていなければなりません。
それ以外では、トークンの間の空白は処理に影響しません (ここでのトークンは左辺の変数、
代入演算子、右辺の式、セミコロンを指します)。

右辺の式が最初に評価されるため、Stan でも C++ や他のプログラミング言語と同じように
変数を変数をインクリメントすることができます。

```
n <- n + 1;
```

このような自己代入は BUGS では許されていません。なぜなら、自己代入は
有向グラフィカルモデル中で循環を引き起こすからです。

代入ステートメントの左辺は配列、行列、ベクトルといったデータ構造に対するインデックスを
含むことがあります。例えば、行列として定義された ``Sigma`` に対して、

```
Sigma[1,1] <- 1.0;
```

という代入ステートメントは、``Sigma`` の 1 行 1 列目の値に ``1`` を代入します。

代入ステートメントにはあらゆるデータ型の複雑なオブジェクトを含むことができます。
``Sigma`` と ``Omega`` が行列、 ``sigma`` が ベクトルの場合、次の代入ステートメントは
成立します。変数のデータ型と式の結果はどちらも ``matrix`` 型になるためです。

```
Sigma
  <- diag_matrix(sigma)
     * Omega
     * diag_matrix(sigma);
```

また、この例は複雑な代入ステートメントを複数の行に分割して記載する場合に望ましい例を
示しています。

Stan は より大きな多次元データ構造中の一部に対する代入もサポートしています。例えば、
``a`` が ``real[~,~]`` 型の配列、``b`` が ``real[]`` 型の配列の場合、以下二つの
代入ステートメントはどちらも成立します。

```
a[3] <- b;
b <- a[4];
```

同じように、``x`` が ``row_vector`` 型、``Y`` が ``matrix`` 型の変数として
宣言されている場合、次の一連の処理は成立します。処理の結果、 ``Y`` の最初の 2 行が
入れ替わります。

```
x <- Y[1];
Y[1] <- Y[2];
Y[2] <- x;
```

#### 左辺値

代入ステートメント中の左辺として適切な式を "左辺値" と呼びます。Stan では、
適切な左辺値はこの 2 種類しかありません。

- 一つの変数
- 一つ以上のインデックスを持つ一つの変数

インデックス指定された変数を左辺値として使うためには、その変数は少なくともインデックスと同じ数の
次元を持っていなければいけません。実数や整数の配列は宣言された数の次元を持ちます。
行列は 2 次元、ベクトルや行ベクトルは 1 次元です。これは分散共分散行列 ( ``cov_matrix``) や
相関行列 ( ``corr_matrix`` )、またそれらのコレスキー因子 ( ``cholesky_factor_cov``,
``cholesky_factor_corr`` )や 昇順のベクトル ( ``orderd`` ), 昇順で正のベクトル
( ``positive_ordered`` ), 2 乗和が 1 となるベクトル (``simplex`` ) といった
制約付きデータ型についてもあてはまります。通常の配列の次元と比べて、行列の配列の次元は 2 多くなり、
ベクトルや行ベクトルの次元は 1 多くなります。左辺値のインデックスの数は左辺の変数の次元よりも
少なくてよいことに注意してください。この時、右辺は多次元で左辺値の次元と一致している必要があります。

<!--
日本語訳した場合にデータ型との対応がわからなくなるため型を追記。
Multiple Indexes の内容は上と重複 (原文の誤植?)のため省略。
-->

#### エイリアス

すべての代入は、事前に右辺の式のをコピーしたかのようにして行われます。
これにより、エイリアスによって発生しうる「代入ステートメントの実行中に右辺の式の値が変更される」
という問題を解決しています。


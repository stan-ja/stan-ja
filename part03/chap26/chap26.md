
## 26. ステートメント (文)

<!--
statement を "文" とした場合、以降説明にて何を指しているか
読み取りにくくなるためカタカナとした
-->

Stan プログラムのブロック ( 28章を参照 ) は、変数の宣言とステートメント (文)
から成り立っています。BUGS と違って、Stan プログラム中の宣言とステートメントはそれらが
記載された順序で実行されます。変数は、それが参照される前に何らかの値 (と何らかのデータ型の宣言)
によって定義されていなければいけません --- そうでない場合、実行結果は未定義となります。

BUGS と同じく、Stan の基本的なステートメントには代入とサンプリングの 2 種類があります。
また、いくつかのステートメントは 連続した処理やfor-each ループの繰り返し処理にグルーピング
できるでしょう。加えて、Stan では ブロック内でのローカル変数の宣言や、セミコロンのみからなる
空のステートメントも許容されています。

### 26.1. 代入ステートメント

代入ステートメントは変数と式からなります。変数はインデックス情報を持つ多変量の場合もあります。
代入ステートメントが実行されると、ステートメントの右辺にある式が評価され、
その結果が左辺の変数 (インデックスがある場合は指定された箇所) に代入されます。
簡単な代入の例は以下のようなものです。

<!--
以降も原文には都度 (indexed) の記載があるが、日本語で簡潔に記載できる語がないため省略
-->

```
n <- 0;
```

このステートメントが実行されると、式 ``0``、つまり 整数のゼロが評価され、変数 ``n`` に代入
されます。代入が成立するためには、右辺の式のデータ型と左辺の変数のデータ型は一致していな
ければなりません。上の例では、``0`` という式は ``int`` 型になるため、
変数 ``n`` は ``int`` 型もしくは ``real`` 型で宣言されていなければなりません。
変数が ``real`` 型で宣言されている場合は、整数のゼロは浮動小数点のゼロに変換されて
変数に代入されます。ステートメントが実行された後は、変数 ``n`` はゼロ (変数のデータ型に応じて整数
もしくは浮動小数点) という値を持ちます。

文法的には、すべての代入ステートメントはセミコロンで終わっていなければなりません。
それ以外では、トークンの間の空白は処理に影響しません (ここでのトークンは左辺の変数、
代入演算子、右辺の式、セミコロンを指します)。

右辺の式が最初に評価されるため、Stan でも C++ や他のプログラミング言語と同じように
変数を変数をインクリメントすることができます。

```
n <- n + 1;
```

このような自己代入は BUGS では許されていません。なぜなら、自己代入は
有向グラフィカルモデル中で循環を引き起こすからです。

代入ステートメントの左辺は``array``、``matrix``、``vector``といったデータ構造に対するインデックスを
含むことがあります。例えば、``matrix``として定義された ``Sigma`` に対して、

```
Sigma[1,1] <- 1.0;
```

という代入ステートメントは、``Sigma`` の 1 行 1 列目の値に ``1`` を代入します。

代入ステートメントにはあらゆるデータ型の複雑なオブジェクトを含むことができます。
``Sigma`` と ``Omega`` が``matrix``、 ``sigma`` が ``vector``の場合、次の代入ステートメントは
成立します。変数のデータ型と式の結果はどちらも ``matrix`` 型になるためです。

```
Sigma
  <- diag_matrix(sigma)
     * Omega
     * diag_matrix(sigma);
```

また、この例は複雑な代入ステートメントを複数の行に分割して記載する場合に望ましい例を
示しています。

Stan は より大きな多変量のデータ構造の一部に対する代入もサポートしています。例えば、
``a`` が ``real[ , ]`` 型の``array``、``b`` が ``real[]`` 型の``array``の場合、以下二つの
代入ステートメントはどちらも成立します。

```
a[3] <- b;
b <- a[4];
```

同じように、``x`` が ``row_vector`` 型、``Y`` が ``matrix`` 型の変数として
宣言されている場合、次の一連の処理は成立します。処理の結果、 ``Y`` の最初の 2 行が
入れ替わります。

```
x <- Y[1];
Y[1] <- Y[2];
Y[2] <- x;
```

#### 左辺値

代入ステートメント中の左辺として適切な式を "左辺値" と呼びます。Stan では、
適切な左辺値はこの 2 種類しかありません。

- 一つの変数
- 一つ以上のインデックスを持つ一つの変数

インデックス指定された変数を左辺値として使うためには、その変数は少なくともインデックスと同じ数の
次元を持っていなければいけません。実数や整数の``array``は宣言された数の次元を持ちます。
``matrix``は 2 次元、``vector``や``row_vector``は 1 次元です。これは分散共分散行列 ( ``cov_matrix``) や
相関行列 ( ``corr_matrix`` )、またそれらのコレスキー因子 ( ``cholesky_factor_cov``、
``cholesky_factor_corr`` )や 昇順のベクトル ( ``orderd`` ), 昇順で正のベクトル
( ``positive_ordered`` )、各要素が ``[0, 1]``で合計が``1``となるベクトル (``simplex`` ) といった
制約付きデータ型についてもあてはまります。通常の``array``の次元と比べて、``matrix``の``array``の次元は 2 多くなり、
``vector``や``row_vector``の``array``の次元は 1 多くなります。左辺値のインデックスの数は左辺の変数の次元よりも
少なくてよいことに注意してください。この時、右辺は多次元で左辺値の次元と一致している必要があります。

<!--
日本語訳した場合にデータ型との対応がわからなくなるため型を追記。
Multiple Indexes の内容は上と重複 (原文の誤植?)のため省略。
-->

#### エイリアス

すべての代入は、事前に右辺の式のをコピーしたかのようにして行われます。
これにより、「代入ステートメントの実行中に右辺の式の値が変更される」ことによって生じる、
エイリアスの潜在的な問題を解決しています。

<!--
以降2.10を元に翻訳
-->

### 26.2. 対数確率加算ステートメント

Stanの実行の基礎は、与えられたパラメータにおける対数確率関数を評価することです。
この関数は事後分布の対数確率密度や付加定数を返します。データと変換データ (transformed data) 
は対数密度が評価される前に定められます。
対数確率の合計は ``0`` で初期化されます。
次に、対象の変数に制約がある場合に生じる対数ヤコビアン調整が対数密度に対して加えられます (これは
最適化のために省略されることがあります)。

モデルブロックでは、サンプリングステートメントと対数確率加算ステートメントが対数密度への加算を行います。
対数確率加算ステートメントは、以下のような式の値を対数密度に直接加算します。<sup>2</sup>

```
target += -0.5 * y * y;
```

ここでの ``target`` というキーワードは実際には変数ではなく、変数のように利用することはできません
(が、特殊な関数を使って ``target`` の値を直接 利用する方法については下記を参照してください)。


<sup>2</sup> この現在の記法は過去のふたつのバージョンを置き換えます。
元々は、変数 ``lp__`` を直接参照したり操作することができました。これはもはや許可されていません。
`target + u` に対応する従来の文法は `increment_log_prob(u)` ですが、この形式は非推奨となり Stan 3 で削除されます。

この例では、標準正規分布にしたがう変数 ``y`` の標準化されていない対数確率が対数確率の合計に加算されます。
一般的には、右辺はどのような式にもなりえます。<sup>3</sup>

<sup>3</sup>乗算のほうが除算よりも効率的なため、このモデルでは式を ``-0.5 * y * y`` と書いたほうが
同じ意味の ``y * y / -2`` よりも効率的です。
どちらの場合も、負数化は (`-0.5` や `-2` として) 数値リテラルに含められます。
`y * y` の代わりに `square(y)` を使うと導関数を事前に計算でき、
利用メモリと自動微分に必要な操作も減らすことができるためさらに効率的です。

ある Stan モデルの全体をこのようにして実装することができます。
たとえば、次のモデルは標準正規分布に従うひとつの変数を抽出します。

```
parameters {
  real y;
}
model {
  target += -0.5 * y * y;
}
```

このモデルでは対数確率関数を以下ように定義しています。

![$$\log p(y) = - \, \frac{y^2}{2} - \log Z$$](fig/fig01.png)

ここで、``Z`` は ``y`` に依存しない正規化定数です。
定数 ``Z`` が慣例的にこのように書かれるのは、線形スケールでの式

![$$p(y) = \frac{1}{Z} \exp\left(-\frac{y^2}{2}\right).$$](fig/fig02.png)

は一般に ``Z`` を使わず以下のように書かれるためです。

![$$p(y) \propto \exp\left(-\frac{y^2}{2}\right).$$](fig/fig03.png)

Stan only requires models to be defined up to a constant that does not depend
on the parameters.　

<!--
意味が取れない。"parameter に関係しない定数は省略できる"ではないのか?
Stan only requires models to be defined up to a constant that depends
on the parameters.　
-->

これは、正規化定数の計算には時間がかかったり評価がしにくいことがしばしばあるため便利です。


#### ベクトル化

`target += ...` ステートメントは、`...` の代わりに引数として `integer`、 `real`、 `vector`、 `row vector`、
`matrix`、ならびに`matrix`や`vector`の`array`を要素とする任意の次元の `array`を含む
どのような式でも受け取ることができます。引数がコンテナ型の場合はその要素の合計が対数密度に加算されます。

#### 対数密度へのアクセス

あるモデルが返した対数密度に `u` という値を加算したい場合は、次のステートメントを使ってください。<sup>4</sup>

```
target += u;
```

一般に、`u` としてあらゆる式がありえます。もし式がコンテナ型の場合、対数密度にはその要素の合計が加算されます。
現在の実行時点までに累積された対数密度を参照するには、`get_lp()` 関数を使ってください。<sup>5</sup>

<sup>4</sup>もともと Stan には対数密度に直接アクセスする変数 ``lp__`` と　``increment_log_prob()`` ステートメントが
ありましたが、前者は削除され、後者は非推奨となりました。

<sup>5</sup> `lp__` の値は`increment_log_prob(u)`や`target += u`で利用されないため、実行終了までヤコビアンだけを保持しています。

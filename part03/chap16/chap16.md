## 16. まばらなデータ構造と不ぞろいなデータ構造

Stanは、まばらなデータ構造も不ぞろいなデータ構造も直接はサポートしていません。しかし、プログラミングの努力をいくらか払うことで両方とも扱うことができます。43章では、特別な目的のための疎行列と密ベクトルとの積を紹介しており、適用可能なところではこれを使うことができますが、この章ではもっと一般的なデータ構造を対象とします。

### 16.1 まばらなデータ構造

まばらなデータ構造のコーディングは難しくなく、行列状のデータ構造をデータベース状のデータ構造に変換するのと同じです。例えば、9.11節で議論したIRTモデルのまばらなデータを考えます。$J$人の生徒と$K$問の問題があり、すべての生徒がすべての問題を解くとすると、データは、$J \times K$の解答の配列として宣言するのが実用的です。

```
data {
  int<lower=1> J;
  int<lower=1> K;
  int<lower=0,upper=1> y[J,K];
  ...
model {
  for (j in 1:J)
    for (k in 1:K)
      y[j,k] ~ bernoulli_logit(delta[k] * (alpha[j] - beta[k]));
...
```

すべての生徒がすべての問題に答えているわけではないなら、この密な配列のコーディングはもはや動作しません。Stanは未定義の値をサポートしていないからです。図16.1は、$J=3$で$K=4$の場合の例で、欠測の応答はRと同じくNAとしています。StanにはRのNA値のサポートはありませんので、このデータ構造を直接使うことはできません。かわりに、データベースのような「長い形式」に変換する必要があります。そのためには、値とは別に、$j$および$k$のインデックスを示す列を持たせます。例えば、$jj$と$kk$をインデックスのために使うと（Gelman and Hill, 2007による）、データ構造は、図16.1の右側の例のようにコーディングできます。この例では、$y_{1,1}=0$、$y_{1,2}=1$などとなっており、最後は$y_{3,2}=1$です。ここにない項目はすべて未定義です。

![$$y = \left[\begin{array}{cccc} 0 & 1 & \mathrm{NA} & 1 \\ 0 & \mathrm{NA} & \mathrm{NA} & 1 \\ \mathrm{NA} & 0 & \mathrm{NA} & \mathrm{NA} \end{array}\right] \quad \begin{array}{ll|l}jj & kk & y \\ \hline 1 & 1 & 0 \\ 1 & 2 & 1 \\ 1 & 4 & 1 \\ 2 & 1 & 0 \\ 2 & 4 & 1 \\ 3 & 2 & 0 \end{array}$$](fig/fig01.png)

図16.1: まばらな配列をStanでコーディングした例。左側は、R由来のNA記法を使った疎行列$y$の定義です（これはStanではサポートされていません）。右側は、同じ疎行列$y$をデータベース状にエンコーディングしたもので、これはStanで直接扱うことができます。最初の2列、$jj$と$kk$はインデックスを示し、最後の列$y$がその値を示します。例えば、右側のデータベース状のデータ構造の5行目は$y_{2,4}=1$を示します。

定義されている$y$の数を$N$とすると、ここでは$N=6$です。データとモデルは以下のように定式化できます。

```
data { ...
  int<lower=1> N;
  int<lower=1,upper=J> jj[N];
  int<lower=1,upper=K> kk[N];
  int<lower=0,upper=1> y[N];
  ...
model {
  for (n in 1:N)
    y[n] ~ bernoulli_logit(delta[kk[n]]
                           * (alpha[jj[n]] - beta[kk[n]]));
...
```

欠測値がない場合には、この2種のモデルの定式化は完全に同じ対数事後密度を生成します。

### 16.2. 不ぞろいなデータ構造

不ぞろいな配列とは、長方形になっておらず、項目によってサイズが違うような配列のことです。この種の構造は、配列ごとに観測回数が違うときに出てきます。

不ぞろいなデータ構造を扱う一般的な方法は、前の節で議論したように、完全なデータベース状のデータ構造に移行することです。より簡潔に、線形の配列に何らかのインデックスをつける方法もあります。

例えば、3群があって、それぞれの観測回数が異なるようなデータ構造を考えます。

とても単純な、切片が変化するモデルを仮定します。ベクトル化した記法を使うと、尤度は以下のようになります（訳注: 原文では積（$\prod$）になっていますが、対数にしているので和（$\sum$）のはずです）。

![$$\sum_{n=1}^{3}\log\mathsf{Normal}(y_{n}\mid\mu_{n},\sigma)$$](fig/fig02.png)

これを直接Stanでエンコードする方法はありません。

まばらなデータの例のように、完全なデータベース型の構造を使うことができるでしょうが、これは非効率です。不要なインデックスがスペースを無駄にしますし、ベクトルによる密度の演算ができません。このデータをコーディングするもっと良い方法は、単一のリストに値を持たせ、各部分配列のサイズを示すデータ構造を別に用意するというものです。図16.2の右側にこれを示しています。このコーディングでは、値のための配列を1つだけ、それから各列のサイズのためにもう1つ別の配列を使っています。

![$$\begin{minipage}[c]{0.35\textwidth} $y_1 = \left[1.3 \ \ 2.4\ \ 0.9\right]$ \\ $y_2 = \left[-1.8\ \ -0.1 \right]$ \\ $y_3 = \left[12.9\ \ 18.7\ \ 42.9\ \ 4.7\right]$ \end{minipage} \begin{minipage}[c]{0.60\textwidth} $z = [1.3\ \ 2.4\ \ 0.9\ \ -1.8\ \ -0.1\ \ 12.9\ \ 18.7\ \ 42.9\ \ 4.7]$ \\ $s  =  \{3\ \ 2\ \ 4 \}$ \end{minipage}$$](fig/fig03.png)

図16.2: 不ぞろいな配列をStanでコーディングした例。左側は、サイズの異なる3行（$y_1$はサイズ3、$y_2$はサイズ2、$y_3$はサイズ4）からなる不ぞろいなデータ構造$y$の定義です。右側は、Stanでこのデータをコーディングする方法の例です。単一のベクトル$y$を使ってすべての値を保持し、整数値の別の配列$s$に、群ごとの行のサイズを持たせています。この例では$y_{1}=z_{1:3}$、$y_{2}=z_{4:5}$、$y_{3}=z_{6:9}$です。

するとこのモデルは、スライシング演算を使って、以下のようにコーディングできます。

```
data {
  int<lower=0> N;  // 観測回数
  int<lower=0> K;  // 群の数
  vector[N] y;     // 観測値
  int s[K];        // 群のサイズ
  ...
model {
  int pos;
  pos <- 1;
  for (k in 1:K) {
    segment(y, pos, s[k]) ~ normal(mu[k], sigma);
    pos <- pos + s[k];
  }
```

このコーディングでは十分なベクトル化が可能で、これは``segment()``によるベクトルのスライシング演算によって生じるコピーのコストに見合うものです。


## 27. ステートメント (文)

<!--
statement を "文" とした場合、以降説明にて何を指しているか
読み取りにくくなるためカタカナとした
-->

Stan プログラムのブロック ( 28章を参照 ) は、変数の宣言とステートメント (文)
から成り立っています。BUGS と違って、Stan プログラム中の宣言とステートメントはそれらが
記載された順序で実行されます。変数は、それが参照される前に何らかの値 (と何らかのデータ型の宣言)
によって定義されていなければいけません --- そうでない場合、実行結果は未定義となります。

BUGS と同じく、Stan の基本的なステートメントには代入とサンプリングの 2 種類があります。
また、いくつかのステートメントは 連続した処理やfor-each ループの繰り返し処理にグルーピング
できるでしょう。加えて、Stan では ブロック内でのローカル変数の宣言や、セミコロンのみからなる
空のステートメントも許容されています。

### 27.1. 代入ステートメント

代入ステートメントは変数と式からなります。変数はインデックス情報を持つ多変量の場合もあります。
代入ステートメントが実行されると、ステートメントの右辺にある式が評価され、
その結果が左辺の変数 (インデックスがある場合は指定された箇所) に代入されます。
簡単な代入の例は以下のようなものです。<sup>1</sup>

<!--
以降も原文には都度 (indexed) の記載があるが、日本語で簡潔に記載できる語がないため省略
-->

```
n = 0;
```

このステートメントが実行されると、式 ``0``、つまり 整数のゼロが評価され、変数 ``n`` に代入
されます。代入が成立するためには、右辺の式のデータ型と左辺の変数のデータ型は一致していな
ければなりません。上の例では、``0`` という式は ``int`` 型になるため、
変数 ``n`` は ``int`` 型もしくは ``real`` 型で宣言されていなければなりません。
変数が ``real`` 型で宣言されている場合は、整数のゼロは浮動小数点のゼロに変換されて
変数に代入されます。ステートメントが実行された後は、変数 ``n`` はゼロ (変数のデータ型に応じて整数
もしくは浮動小数点) という値を持ちます。

<sup>1</sup>Stan の 2.10.0 より前のバージョンでは、代入には等号 `=`ではなく `<-` 演算子が用いられていました。
`<-` 演算子は現在では非推奨となり警告が表示されます。`<-` 演算子は将来のバージョンで削除されます。

文法的には、すべての代入ステートメントはセミコロンで終わっていなければなりません。
それ以外では、トークンの間の空白は処理に影響しません (ここでのトークンは左辺の変数、
代入演算子、右辺の式、セミコロンを指します)。

右辺の式が最初に評価されるため、Stan でも C++ や他のプログラミング言語と同じように
変数を変数をインクリメントすることができます。

```
n = n + 1;
```

このような自己代入は BUGS では許されていません。なぜなら、自己代入は
有向グラフィカルモデル中で循環を引き起こすからです。

代入ステートメントの左辺は``array``、``matrix``、``vector``といったデータ構造に対するインデックスを
含むことがあります。例えば、``matrix``として定義された ``Sigma`` に対して、

```
Sigma[1,1] = 1.0;
```

という代入ステートメントは、``Sigma`` の 1 行 1 列目の値に ``1`` を代入します。

代入ステートメントにはあらゆるデータ型の複雑なオブジェクトを含むことができます。
``Sigma`` と ``Omega`` が``matrix``、 ``sigma`` が ``vector``の場合、次の代入ステートメントは
成立します。変数のデータ型と式の結果はどちらも ``matrix`` 型になるためです。

```
Sigma
  = diag_matrix(sigma)
     * Omega
     * diag_matrix(sigma);
```

また、この例は複雑な代入ステートメントを複数の行に分割して記載する場合に望ましい例を
示しています。

Stan は より大きな多変量のデータ構造の一部に対する代入もサポートしています。例えば、
``a`` が ``real[ , ]`` 型の``array``、``b`` が ``real[]`` 型の``array``の場合、以下二つの
代入ステートメントはどちらも成立します。

```
a[3] = b;
b = a[4];
```

同じように、``x`` が ``row_vector`` 型、``Y`` が ``matrix`` 型の変数として
宣言されている場合、次の一連の処理は成立します。処理の結果、 ``Y`` の最初の 2 行が
入れ替わります。

```
x = Y[1];
Y[1] = Y[2];
Y[2] = x;
```

#### 左辺値

代入ステートメント中の左辺として適切な式を "左辺値" と呼びます。Stan では、
適切な左辺値はこの 2 種類しかありません。

- 一つの変数
- 一つ以上のインデックスを持つ一つの変数

インデックス指定された変数を左辺値として使うためには、その変数は少なくともインデックスと同じ数の
次元を持っていなければいけません。実数や整数の``array``は宣言された数の次元を持ちます。
``matrix``は 2 次元、``vector``や``row_vector``は 1 次元です。これは分散共分散行列 ( ``cov_matrix``) や
相関行列 ( ``corr_matrix`` )、またそれらのコレスキー因子 ( ``cholesky_factor_cov``、
``cholesky_factor_corr`` )や 昇順のベクトル ( ``orderd`` ), 昇順で正のベクトル
( ``positive_ordered`` )、各要素が ``[0, 1]``で合計が``1``となるベクトル (``simplex`` ) といった
制約付きデータ型についてもあてはまります。通常の``array``の次元と比べて、``matrix``の``array``の次元は 2 多くなり、
``vector``や``row_vector``の``array``の次元は 1 多くなります。左辺値のインデックスの数は左辺の変数の次元よりも
少なくてよいことに注意してください。この時、右辺は多次元で左辺値の次元と一致している必要があります。

<!--
日本語訳した場合にデータ型との対応がわからなくなるため型を追記。
Multiple Indexes の内容は上と重複 (原文の誤植?)のため省略。
-->

#### エイリアス

すべての代入は、事前に右辺の式のをコピーしたかのようにして行われます。
これにより、「代入ステートメントの実行中に右辺の式の値が変更される」ことによって生じる、
エイリアスの潜在的な問題を解決しています。

## 22. 自作の確率分布関数
自作の確率分布もStanの中で直接実装することができます。必要なことは対数確率の合計を累積する（インクリメントする）ことだけです。以降では2つの例を扱います。

### 22.1.　例
#### 三角分布
単純な例は三角分布です。その密度関数は二等辺三角形のような形をしており、指定された境界において角をもち、密度を積分すると1になるという制約から高さが決まります。もし、$\alpha \in \mathbb{R}$と$\beta \in \mathbb{R}$が境界で、$\alpha < \beta$とすると、$y \in (\alpha, \beta)$は以下で定義される密度を持ちます。

$$\mathsf{Triangle}(y \mid \alpha,\beta) = \frac{2}{\beta - \alpha}\left( 1 - \left| y - \frac{\alpha + \beta}{\beta - \alpha} \right| \right)$$

もし、$\alpha = -1$、$\beta = 1$、$y \in (-1, 1)$ならば、この式は以下のように簡単になります。

$$\mathsf{Triangle}(y \mid -1,1) = 1 - |y|$$

$\mathsf{Triangle}(-1,1)$からサンプリングするため、以下のStanの実装を考えてみましょう。^[プログラムは<https://github.com/stan-dev/example-models/tree/master/basic_distributions>から入手可能です。]

```
parameters {
  real<lower=-1,upper=1> y;
}
model {
  target += log1m(fabs(y));
}
```

唯一のスカラーのパラメータである`y`が区間`(-1,1)`に入るように宣言されています。対数確率の合計に、すべてのパラメータの同時対数確率（すなわち$\log \mathsf{Triangle}(-1,1)$）を加えてインクリメントしています。この同時対数確率の値はStanでは`log1m(fabs(y))`とコーディングされています。`log1m(x)`関数は`log(1.0-x)`と同じ値ですが、計算がより速く、より正確で、より安定です。

`y`の宣言における型の制約`real<lower=-1,upper=1>`は、正しくサンプリングが行われるために必須です。もし、プログラムから`y`の制約を取り除いたら、すなわち`y`が制約のない実数値をとるように宣言すると、プログラムはコンパイルされるけれども、実行時においてサンプラーが$(-1,1)$の外側を探索した時に算術例外を投げることでしょう。

以下のように$(-1,1)$の外側の値に`log(0.0)`の対数確率（すなわち負の無限大）を定義することで、$\mathbb{R}$全体の値に拡張した対数確率関数を考えてみましょう。

```
target += log(fmax(0.0,1 - fabs(y)));
```

`y`に制約を課した元のプログラムと比べて、これは非効率で遅くて数値計算上不安定です。しかし、`y`についての制約を取り除いても、プログラムはコンパイルされ、算術例外が発生することなしに実行されるでしょう。しかし、適切にサンプリングはされないでしょう。^[問題は三角分布の裾が（とても！）軽いことです。標準のHMCやNUTSサンプラーは三角分布の角にうまく入っていくことができません。一方はじめのStanコードでは、`y`の型を`real<lower=-1,upper=1>`と宣言しているので、制約のない変数に逆ロジット変換が適用され、その変換のヤコビアンの絶対値の対数が対数確率に足されます。結果的に得られるロジット変換された`y`の分布は問題なく振る舞います。Stanで使われる変換についてもっと情報が知りたい場合は34章を参照してください。]


#### 指数分布
もし、仮にStanに指数分布が用意されていないとすると、指数分布は以下の代入文を用いて直接コーディングできます。

```
target += log(lambda) - y * lambda;
```

ここで`lambda`はスケールの逆数で、`y`はサンプリングされた確率変数を表します。このコーディングは任意の`lambda`と`y`についてうまくいきます。これらの両方もしくはどちらか一方がパラメータでもデータでもよいですし、ローカル変数でも大丈夫です。

前の段落の代入文は、以下のサンプリング文によって生成されるC++コードと非常によく似たC++コードを生成します。

```
y ~ exponential(lambda);
```

注目すべき違いが二つあります。一つ目は、サンプリング文は`lambda`が正で`y`が非負であることを確認するため入力をチェックします（どちらも非数でないかもチェックします）。

二つ目の違いは、もし`lambda`がパラメータ・変換パラメータ（transformed parameter）・`model`ブロックの局所変数のいずれでもなければ、サンプリング文は賢いので定数である`log(lambda)`の項を落とします。結果は同じ事後分布になります。なぜなら、Stanは付加定数を除いた対数確率だけを必要とするからです。もし、`lambda`と`y`の両方とも定数ならば、サンプリング文は両方の項を落とします（しかし、入力が妥当かどうかのチェックは変わらず行います）。

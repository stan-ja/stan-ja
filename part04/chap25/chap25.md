## 25. 行列、ベクトル、配列

Stanには、行列やベクトル、配列といったさまざまなデータ構造が用意されています。
この章ではその選び方へのポインターを示します。

### 25.1 基本的な動機付け

Stanには、基本スカラー型として`int`（整数）と`real`（実数）の2つが、基本線形代数型として`vector`（ベクトル）、`row_vector`（行ベクトル）と`matrix`（行列）の3つが用意されています。
そしてStanでは、配列はどんな次元でも持てますし、どんな型の要素でも含めることができます（しかし型は宣言する必要があり、すべての要素で同じでなくてはなりません）。

3種類の1次元コンテナーがあるので、迷うことがあります。以下の宣言がその例です。

```
real a[N];
vector[N] a;
row_vector[N] a;
```

この違いは重要です。
行列型は、ベクトルと行ベクトルと同様、線形代数演算に必要です。
配列はベクトルに自動昇格はしません。昇格先が行ベクトルなのか列ベクトルなのか、決まらないからです。
同様に、行ベクトルは列ベクトルと区別されます。行ベクトルに列ベクトルをかけるとスカラーになり、逆の順序でかけると行列になるからです。

以下のコード片は、$M \times N$のサイズの2次元コンテナーを宣言する4つの方法すべてを示してます。

```
real b[M, N];          // b[m] : real[]     (効率的)
vector[N] b[M];        // b[m] : vector     (効率的)
row_vector[N] b[M];    // b[m] : row_vector (効率的)
matrix[M, N] b;        // b[m] : row_vector (非効率)
```

これらの主要な相違点には、さまざまな目的での効率性や、`b[m]`の型があります。`b[m]`の型については上の宣言の右側のコメントで示しています。

コンテナーを手動で変形することによる効率の低下は、どのようなものでも、Stanのプログラムで行なわれるその他のことに比べれば通常はわずかなものです。

### 25.2 固定サイズと、インデックスが境界を超えたとき

Stanの行列、ベクトル、配列変数は宣言のときにサイズが決まり、動的にサイズが変わることはありません。
関数の引数にはサイズがありませんが、関数が呼ばれ、コンテナーがインスタンス化されたときにサイズが固定されます。
また、宣言はループ中でも可能ですので、プログラムの実行経過で宣言が変わる可能性がありますが、宣言のたびに、固定サイズのオブジェクトを宣言します。

与えられたインデックスが境界を超えたときには、Stanは却下エラーを出して、現在の対数密度の計算と勾配評価を中止し、アルゴリズムは停止してエラーを処理します。
すべてのStanのコンテナーは、すべてのインデックスのサイズをチェックします。

### 25.3 データ型とインデキシングの効率性

Stanにおいて、行列と線形代数の演算はEigen C++ライブラリのデータ型をベースに実装されています。ベクトルと行列が基本の型としてあるので、行列演算や線形代数の関数を使用する際、型の変換は必要ありません。

他方、配列はC++の`std::vector`クラスのインスタンスとして実装されています。(Eigenライブラリの`Eigen::vector`クラスや、 Stanのベクトルと混同しないように注意しましょう)。配列はこのように実装されているため、インデックスにおける値を返すのはとても効率的です。なぜならコピーして値を返すのではなく参照を使って値を返すからです。

#### 行列 vs. 2次元配列

Stanのモデルにおいて、2次元配列と行列のどちらを使うか決めるときに、効率を少し上げるために考えることがいくつかあります。一見、2次元配列と行列のどちらを使ってもよく思われるかもしれませんが。

第1に、行列は2次元配列よりもメモリの使用量がわずかに少ない点です。これは、行列では、配列の並び方は保存せず、データと2つの次元の情報だけを保存しているためです。

第2に、行列は「列優先」の順序でデータを格納する点です。さらに、行列内のすべてのデータはメモリ内で隣接することが保証されます。これは最適化されたコードを考えると大切なことです。なぜなら現代のCPUを使った算術演算を実行することよりも、データをメモリからキャッシュに持っていくことの方がはるかに時間がかかるからです。
他方、配列はプリミティブ型の値はメモリ内で隣接することを保証しており、それ以外の場合はその値のコピーを保持します（可能な限り、参照を使って値を返します）。

第3に、いずれのデータ構造もデータが保持されている順序でインデックスを移動させると最も速くアクセスできます。メモリ上の位置もアクセス速度に関係します。行列は列優先であるため、以下の順序でインデックスを移動させるのが適切です。

```
matrix[M, N] a;
//...
for (n in 1:N)  //列が先
  for (m in 1:M)  //行が後
    // ... a[m, n]を使った処理...
```

他方、配列は以下の例のように行優先の順序でインデックスを移動させるべきです（すなわち、最後のインデックスが最も移動するのが速い）。

```
real a[M, N];
// ...
for (m in 1:M)  //行が先
  for (n in 1:N)  //列が後
    // ... a[m, n]を使った処理...
```

最初に`a[m, n]`を使う際には、`a[m]`をメモリに持ってくるように書くべきです。一般的に、`matrix`内の移動は、配列内の移動よりも効率が良いのです。
これは`matrix`の配列についても同様です。例えば、`matrix`の2次元配列のインデックスを移動してアクセスするのに理想的な順序は以下になります。

```
matrix[M, N] b[I, J];
// ...
for (i in 1:I)  //配列なので行が先
  for (j in 1:J)  //配列なので列が後
    for (n in 1:N)  //行列なので列が先
      for (m in 1:M) //行列なので行が後
        //... b[i, j, m, n] を使った処理...
```

`a`が行列の場合、`a[m]`と表記すると、その行列の行`m`が抽出されます。これは行列を取り扱う上では非効率な操作です。もし複数のベクトルにインデックスでアクセスする必要があるならば、ベクトルの配列を宣言する方がはるかに良いのです。

```
row_vector[N] b[M];
// ...
for (m in 1:M)
  //... 行ベクトルb[m]を使った処理 ...
```

これは以下の行列を使った例よりも圧倒的に効率的です。

```
matrix b[M,N];
// ...
for (m in 1:M)
  // ... 行ベクトルb[m]を使った処理  ...
```

同様に、列ベクトルの配列に対してインデックスを移動させてアクセスする方が、行列の列を抽出する`col`関数を使うよりも効率的です。

対照的に、行列演算や線形代数の関数として行われることは何でも行列が一番速いでしょう。だから、もし予測変数と係数のドット積（訳注: 要素ごとにかけて和をとったもの, 内積）の行を作成したい場合には、以下のように記述すると、

```
matrix[N,K] x; // 予測変数（説明変数, 共変量ともいう）
// ...
vector[K] beta; // 係数
// ...
vector[N] y_hat; // 線形予測
// ...
y_hat = x * beta;
```

以下よりも効率的です。

```
  row_vector[K] x[N]; // 予測変数（説明変数, 共変量ともいう）
  // ...
  vector[K] beta; // 係数
  ...
  vector[N] y_hat; // 線形予測
  ...
  for (n in 1:N)
    y_hat[n] = x[n] * beta;
```

#### （列）ベクトル vs. 1次元配列

純粋にコンテナーとして使うときには、ベクトルと行ベクトル、1次元配列との間にはまったく違いがありません。。`Eigen:Vector`テンプレートと、`C++`の`std:vector`テンプレートクラスは、`double`型の値のコンテナーとして非常に近い形で実装されています (Stanでは`real`型)。ただし、Stanにおいて整数値を格納できるのは配列だけです。

### 25.4 メモリーでの位置

行列とベクトルの表現での効率性を理解する鍵は、メモリーでの位置と、参照渡しとコピーとの違いです。

#### メモリーでの位置

計算機のCPUは、キャッシュ層を通じてメモリーをブロックで持ってきます。
メモリーからの取り込みは、算術演算を実行することに比べると**はるかに**遅いのです。
コンテナーの演算を高速にする唯一の方法は、メモリーでの位置を考慮して、メモリー内で隣接している要素をプログラム中で連続的にアクセスするようにすることです。

#### 行列

行列は、内部では列優先順で格納されます。
つまり、$M \times N$行列は以下の順に要素を格納します。

$$
(1, 1), (2, 1),\dots,(M, 1), (1, 2),\dots,(M, 2),\dots,(1, N),\dots,(M, N)
$$

これは、行列については列でループを回すように書く方がはるかに効率的であることを意味します。
以下がその例です。

```
matrix[M, N] a;
...
for (n in 1:N)
  for (m in 1:M)
    ... a[m, n]をつかった処理...
```

同様に、行列から行を抜きだすときも、近隣のメモリーにアクセスすることになりません。値の列全体にわたってとびとびにアクセスすることになります。
行は、内部では行列の単位として格納されていませんから、新しいデータ構造へのコピー操作が必要になります。
行列の行ベクトルに、連続してアクセスする場合には、行ベクトルの配列とした方がはるかに良いのです。以下がその例です。

```
row_vector[N] a[M];
...
for (m in 1:M)
  ... 行ベクトルa[m]をつかった処理...
 ```

処理に関数呼び出しが含まれている場合でも、行ベクトル`a[m]`はコピーされないでしょう。

#### 配列

配列は、内部ではデータ構造にしたがって格納されます。
これは、2次元配列では行優先順で格納されることを意味します。
したがって、2次元配列から「行」を抜き出すのは効率的です。

```
real a[M, N];
...
for (m in 1:M)
  ... a[m]についての処理...
```

行列と違うところは、2次元配列の項目`a[m]`は必ずしもメモリー内で隣接しているとは限らないという点です。そのため、2次元配列の要素すべてについてループさせるときも、「行」に沿って近隣のメモリーにアクセスするという保証はありません。

### 25.5. 行列、ベクトル、配列の型変換

行列、ベクトル、配列の自動変換はStanにはありません。
しかし、豊富な変換関数があり、行列をベクトルに変換したり、多次元配列を1次元配列に変換したり、ベクトルを配列に変換したりできます。
利用可能な変換関数の完全な詳細は44章を参照してください。また26章には、multiple indexingとrange indexingを含む変形操作についていくらか書かれています。

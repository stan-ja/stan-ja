# Overview
このドキュメントは統計モデリング言語であるStanのユーザーガイド，リファレンスマニュアルです．導入の章ではStanの全体像について紹介しますが，残りの章ではモデルの実際のプログラミングや，Stanのモデリング言語としての詳細な解説を，コードやデータの型も含めて，実践的な解説を行います．

## 1.1 Stan Home Page

最新のコード，例，マニュアル，バグレポート，機能追加の要望など，Stanに関する情報は下記のリンクにあるStanのホームページから参照できます．

[http://mc-stan.org](http://mc-stan.org)

## 1.2 Stanのインターフェース
Stan Projectでは３つのインターフェースをプロジェクトの一部としてサポートしています．モデリング部分やその使い方に関しては３つのインターフェースで共通していてるので，このマニュアルはその３つに共通するモデリング言語としてのマニュアルとなります．
すべてのインターフェースについて初期化やサンプリング，チューニング方法について共通していて，また事後分布を分析する機能についてもおおまかに共有されています．

提供されているすべてのインターフェースについて，getting-started guideやドキュメントが完全なソースコードと共に提供されています．

### CmdStan
CmdStanはコマンドラインからStanを利用することを可能にします．ある意味でCmdStanはStanのリファレンス実装ともいえます．もともとCmdStanのドキュメントはこのドキュメントの一部でしたが，今では独立したドキュメントとなっています．CmdStanのホームページは下記になります

[http://mc-stan.org/cmdstan.html](http://mc-stan.org/cmdstan.html)

### RStan
RStanはRにおけるStanのインターフェースです．RStanは，R2WinBUGSとR2jagsのモデルのように外側からStanを呼び出しているというよりは，むしろRのメモリに対するインターフェースです．RStanのホームページは下記のとおりです．

[http://mc-stan.org/cmdstan.html](http://mc-stan.org/cmdstan.html)

### PyStan
PyStanはPythonにおけるStanのインターフェースです．RStanと同様に外側のStanを呼び出すというよりは，pythonのメモリレベルのインターフェースです．PyStanのホームページは下記です．

[http://mc-stan.org/pystan.html](http://mc-stan.org/pystan.html)


### MatlabStan
MatlabStanはMatlabにおけるStanへのインターフェースです．RstanやPyStanとは異なり,現状MatlabStanはCmdStanのラッパーです．MatlabStanのホームページは下記のとおりです．

[http://mc-stan.org/matlab-stan.html](http://mc-stan.org/matlab-stan.html)

### Stan.jl
Stan.jlはJuliaにおけるStanのインターフェースです．これもMatlabStanと同様に，CmdStanのラッパーです．Stan.jlのホームページは以下のとおりです．

[http://mc-stan.org/julia-stan.html](http://mc-stan.org/julia-stan.html)

### StataStan
StataStanはStataにおけるStanのインターフェースです．MatlabStan，Stan.jl と同様にこれもCmdStanのラッパーです．StataStanのホームページは下記になります．

[http://mc-stan.org/stata-stan.html](http://mc-stan.org/stata-stan.html)


## 1.3 Stanのプログラム
Stanのプログラムは条件付き確率分布 $p(\theta|x, y)$により定義されます．ここで$\theta$はモデリングしたい未知の値の列(例： モデルの変数, 隠れ変数, 欠損データ, 将来の予測値)で，$y$はモデリングされる既知の変数列，$x$はモデリングされない説明変数の列で定数です（例：サイズ，ハイパーパラメタ）．

Stanのプログラムは，変数の型宣言と文からなります．変数の型には整数，実数，ベクトル，行列はもちろん，その他の型の（多次元な）配列があり，それぞれ値を制限することもできます．

変数は，その役割に応じて，data, transformed data, parameter, transformed parameter, generated quantityなるブロックの中で定義され，制約のないローカル変数はステートメントブロックで定義することができます．

transformed data，transformed parameter，generated quantitiesのブロックは，そのブロックで宣言された変数の定義文を含んでいます．

特別なmodelブロックはモデルの対数尤度を定義する文で構成されています．またBUGS風のサンプリング記法が対数尤度をインクリメントするための略記として利用することが出来，その値により対数尤度関数が定義されます．

対数尤度の変数はユーザ定義関数と，その変換のヤコビアンに直接アクセスすることができます．

### 変数の制限
変数の制限はStanにおいて，とくにparametersにおいて重要な要素です．Stanが効率的にサンプリングをするためには，制約を課した変数に関しては，モデルブロックにおいてその台（サポート）を含んでいる必要があります（言い換えると，ゼロでない事後確率をもつ必要があります）．

dataブロックとtransformed dataブロックにおいて，変数の制約はただ入力や変換のエラーを確認するのみです．transformed parametersブロックにおける制約は，パラメタの制約，もしくはランダムウォーク時にもその条件を満たす必要があり，さもなくばサンプリングは失敗します．generated quantitiesにおける制約は，サンプリングが成功させるか，もしくは停止させます．そのブロックが評価される時点でそのドローを棄却するにはタイミングが遅すぎるためです．

### 実行命令
Stanの文は命令として解釈されるため，順序が重要です．単一の文は変数に対する値の割り付けで，そうした文の列（と必要に応じて局所変数の定義）によりブロックは構成されます．そしてStanもまたRやBUGSで使われていた有限なfor-eachのループを提供しています．

### 確率的プログラミング言語
Stanは命令的で確率的なプログラミング言語です．DSLの一種で，統計的な推論を用いる特定領域のために開発されました．
「確率的」というのは確率変数を正真正銘の第一級オブジェクトとして扱うので，その意味で「確率的」なプログラミング言語です．
Stanでは，全ての変数を確率変数として扱いますが，その確率変数たちが一部は観測されたものとして，また一部は推定分布を推定したいもの，あるいは事後分布の推論に使用されると考えます．観測された確率変数はdataブロックの中で宣言され，観測されていない変数はparametersブロックで宣言されます（もちろんtransformed parameters, generated quantities の値や，それに依存する局所変数も同様です）
また，観測されていない変数たちは，周辺分布や結合分布の平均と分散を推定したり，もしくは他の階層の事後分布推論に接続することもできます．
Stanはまた，「命令的」プログラミング言語でもあります．というのもCやFortranなどと同様(C++や，R，Pythonもしくは Javaなども同じ)に，代入，ループ，条件分岐や局所変数，オブジェクトレベルの関数や，配列のようなデータ構造に基づいてい
ます．
関数型言語と比較すれば，典型的には関数型言語は高階関数（汎関数）や，目的言語に対するプログラミング言語要素のリフレクションが利用できたり，一方で純粋な関数型言語では全面的に代入を許可していなかったりします．
またオブジェクト指向言語は動的に関数が割り当てられる一般的なデータ型を取り入れています．

Stan言語は，CやRがそうであるのと同様に，Church-Turing complete [Church (1936); Turing (1936); Hopcroft and Motwani (2006)]です．それはTuring machine（もしくはC）で計算可能ないかなるプログラムもStanで実装出来ることを意味しています（もちろんその道は険しいですが）．ちなみにTuring Completeであるために求められるのはただ，ループと条件分岐，そしてループの中でサイズが変更できる配列，それで全てです．

## 1.4 コンパイルとStanプログラムの事項
Stanのコードはまず最初にStanのコンパイラ`stanc`によってC++の言語へと変換され，そしてそのC++はプラットフォーム依存の単独で実行可能な形式に変換されます．またStanはWindows，Mac OS X，Linuxなど様々な形式の実行可能形式を出力することが出来ます．
Stanの実行ファイルを実行すると，まずモデルの情報を読み込み，そして既知の$y$と$x$を評価し，そして（独立ではない）同一分布に従うサンプルの列$\theta^{(1)},\theta^{(2)},\dots$を生成し，そこから周辺分布$p(\theta | y, x)$を得ます．

## 1.5 サンプリング
連続変数に対してStanは Hamiltonian Monte Carlo (HMC) Sampling (Du- ane et al., 1987; Neal, 1994, 2011) というある種のマルコフ連鎖モンテカルロ（MCMC）サンプリング(Metropolis et al., 1953)を用います．Stanは離散変数のサンプリングは提供していません．観測値としては離散値を直接利用することが出来ますが，推定するべきパラメタとしてはモデルの外側で周辺化されている必要があります．10章と12章では，いかにして離散で有界なパラメタをモデルの外に掃き出すか，離散的なサンプルに対して大きな効率改善を為すについて議論されています．

HMCは定常分布への収束とパラメタの探索の効率を対数尤度関数の勾配を使うことで改善しています．推定すべき量のベクトル$\theta$は仮想的な粒子の状態に変換されます．それぞれのイテレーションはそのランダムな運動量を生成し，（負の）対数尤度関数によって決まる潜在エネルギーにより粒子の経路をシミュレーションします．ハミルトン分解からこのポテンシャルの勾配が運動量の変化を与え，この運動量が位置の変化を与えることが分かります．この時間的に連続な変化は，時間をシミュレーションが容易な離散値とみなすleapfrogアルゴリズムによって近似されます．メトロポリス法の棄却ステップは逐次，様々なシミュレーションエラーとマルコフ連鎖における詳細釣り合い条件を満たさせるために適用されます (Metropolis et al., 1953; Hastings, 1970)．

基本的なユークリッド空間上のHamiltonian Monte Carlo法には，振る舞いに対して大きな影響を与える３つのチューニングするべきパラメタがあります．Stanのサンプラはそれらを手動で設定する方法と，ユーザを介さずに自動で設定する方法の両方を提供しています．

ひとつ目のチューニングパラメタはステップサイズで，ハミルトニアンの計測された一時的な単位（言い換えると，離散化の単位）です．Stanのサンプラはユーザが指定したサイズに設定することも出来ますが，双対平均化法(Nesterov, 2009; Hoffman and Gelman, 2011, 2014)によって焼き捨ての段階で最適なステップサイズを推定する事が出来ます．どちらの場合もテップサイズは有効な区間から抽出するという方法で，追加のノイズを加えます(Neal, 2011)．

２つめのチューニングパラメタはイテレーション間のステップ数で，このステップ数とステップサイズの積により全体のHamiltonian simulationにかかる時間が決定します．Stanはこのステップ数も特定のステップ数を指定することが出来ますが，No-U-Turn (NUTS) sampler (Hoffman and Gelman, 2011, 2014)を使う場合はこのステップ数を自動的に決定する事ができます．

３つ目のチューニングパラメタは，仮想粒子の質量行列です．Stanはこの対角行列となる質量行列や完全な質量行列を推定するために焼き捨てを通じて設定され，将来的にはユーザが指定した質量行列をサポートする予定です．






# Overview
このドキュメントは統計モデリング言語であるStanのユーザーガイド，リファレンスマニュアルです．導入の章ではStanの全体像について紹介しますが，残りの章ではモデルの実際のプログラミングや，Stanのモデリング言語としての詳細な解説を，コードやデータの型も含めて，実践的な解説を行います．

## 1.1 Stan Home Page

最新のコード，例，マニュアル，バグレポート，機能追加の要望など，Stanに関する情報は下記のリンクにあるStanのホームページから参照できます．

[http://mc-stan.org](http://mc-stan.org)

## 1.2 Stanのインターフェース
Stan Projectでは３つのインターフェースをプロジェクトの一部としてサポートしています．モデリング部分やその使い方に関しては３つのインターフェースで共通していてるので，このマニュアルはその３つに共通するモデリング言語としてのマニュアルとなります．
すべてのインターフェースについて初期化やサンプリング，チューニング方法について共通していて，また事後分布を分析する機能についてもおおまかに共有されています．

提供されているすべてのインターフェースについて，getting-started guideやドキュメントが完全なソースコードと共に提供されています．

### CmdStan
CmdStanはコマンドラインからStanを利用することを可能にします．ある意味でCmdStanはStanのリファレンス実装ともいえます．もともとCmdStanのドキュメントはこのドキュメントの一部でしたが，今では独立したドキュメントとなっています．CmdStanのホームページは下記になります

[http://mc-stan.org/cmdstan.html](http://mc-stan.org/cmdstan.html)

### RStan
RStanはRにおけるStanのインターフェースです．RStanは，R2WinBUGSとR2jagsのモデルのように外側からStanを呼び出しているというよりは，むしろRのメモリに対するインターフェースです．RStanのホームページは下記のとおりです．

[http://mc-stan.org/cmdstan.html](http://mc-stan.org/cmdstan.html)

### PyStan
PyStanはPythonにおけるStanのインターフェースです．RStanと同様に外側のStanを呼び出すというよりは，pythonのメモリレベルのインターフェースです．PyStanのホームページは下記です．

[http://mc-stan.org/pystan.html](http://mc-stan.org/pystan.html)


### MatlabStan
MatlabStanはMatlabにおけるStanへのインターフェースです．RstanやPyStanとは異なり,現状MatlabStanはCmdStanのラッパーです．MatlabStanのホームページは下記のとおりです．

[http://mc-stan.org/matlab-stan.html](http://mc-stan.org/matlab-stan.html)

### Stan.jl
Stan.jlはJuliaにおけるStanのインターフェースです．これもMatlabStanと同様に，CmdStanのラッパーです．Stan.jlのホームページは以下のとおりです．

[http://mc-stan.org/julia-stan.html](http://mc-stan.org/julia-stan.html)

### StataStan
StataStanはStataにおけるStanのインターフェースです．MatlabStan，Stan.jl と同様にこれもCmdStanのラッパーです．StataStanのホームページは下記になります．

[http://mc-stan.org/stata-stan.html](http://mc-stan.org/stata-stan.html)


## 1.3 Stanのプログラム
Stanのプログラムは条件付き確率分布 $p(\theta|x, y)$により定義されます．ここで$\theta$はモデリングしたい未知の値の列(例： モデルの変数, 隠れ変数, 欠損データ, 将来の予測値)で，$y$はモデリングされる既知の変数列，$x$はモデリングされない説明変数の列で定数です（例：サイズ，ハイパーパラメタ）．

Stanのプログラムは，変数の型宣言と文からなります．変数の型には整数，実数，ベクトル，行列はもちろん，その他の型の（多次元な）配列があり，それぞれ値を制限することもできます．

変数は，その役割に応じて，data, transformed data, parameter, transformed parameter, generated quantityなるブロックの中で定義され，制約のないローカル変数はステートメントブロックで定義することができます．

transformed data，transformed parameter，generated quantitiesのブロックは，そのブロックで宣言された変数の定義文を含んでいます．

特別なmodelブロックはモデルの対数尤度を定義する文で構成されています．またBUGS風のサンプリング記法が対数尤度をインクリメントするための略記として利用することが出来，その値により対数尤度関数が定義されます．

対数尤度の変数はユーザ定義関数と，その変換のヤコビアンに直接アクセスすることができます．

### 変数の制限
変数の制限はStanにおいて，とくにparametersにおいて重要な要素です．Stanが効率的にサンプリングをするためには，制約を課した変数に関しては，モデルブロックにおいてその台（サポート）を含んでいる必要があります（言い換えると，ゼロでない事後確率をもつ必要があります）．

dataブロックとtransformed dataブロックにおいて，変数の制約はただ入力や変換のエラーを確認するのみです．transformed parametersブロックにおける制約は，パラメタの制約，もしくはランダムウォーク時にもその条件を満たす必要があり，さもなくばサンプリングは失敗します．generated quantitiesにおける制約は，サンプリングが成功させるか，もしくは停止させます．そのブロックが評価される時点でそのドローを棄却するにはタイミングが遅すぎるためです．

### 実行命令
Stanの文は命令として解釈されるため，順序が重要です．単一の文は変数に対する値の割り付けで，そうした文の列（と必要に応じて局所変数の定義）によりブロックは構成されます．そしてStanもまたRやBUGSで使われていた有限なfor-eachのループを提供しています．

### 確率的プログラミング言語
Stanは命令的で確率的なプログラミング言語です．DSLの一種で，統計的な推論を用いる特定領域のために開発されました．
「確率的」というのは確率変数を正真正銘の第一級オブジェクトとして扱うので，その意味で「確率的」なプログラミング言語です．
Stanでは，全ての変数を確率変数として扱いますが，その確率変数たちが一部は観測されたものとして，また一部は推定分布を推定したいもの，あるいは事後分布の推論に使用されると考えます．観測された確率変数はdataブロックの中で宣言され，観測されていない変数はparametersブロックで宣言されます（もちろんtransformed parameters, generated quantities の値や，それに依存する局所変数も同様です）
また，観測されていない変数たちは，周辺分布や結合分布の平均と分散を推定したり，もしくは他の階層の事後分布推論に接続することもできます．
Stanはまた，「命令的」プログラミング言語でもあります．というのもCやFortranなどと同様(C++や，R，Pythonもしくは Javaなども同じ)に，代入，ループ，条件分岐や局所変数，オブジェクトレベルの関数や，配列のようなデータ構造に基づいてい
ます．
関数型言語と比較すれば，典型的には関数型言語は高階関数（汎関数）や，目的言語に対するプログラミング言語要素のリフレクションが利用できたり，一方で純粋な関数型言語では全面的に代入を許可していなかったりします．
またオブジェクト指向言語は動的な関数の呼び出しによって，より一般的なデータ型を取り入れることが出来ます．

Stan言語は，CやRがそうであるのと同様に，Church-Turing complete [Church (1936); Turing (1936); Hopcroft and Motwani (2006)]です．それはTuring machine（もしくはC）で計算可能ないかなるプログラムもStanで実装出来ることを意味しています（もちろんその道は険しいですが）．ちなみにTuring Completeであるために求められるのはただ，ループと条件分岐，そしてループの中でサイズが変更できる配列のみです．










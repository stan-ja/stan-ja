## 9. 切断あるいは打ち切りデータ

測定値に切断や打ち切りがあるデータは、Stanでは以下のそれぞれの確率モデルのようにコーディングできます。

### 9.1. 切断分布

Stanで切断を使える分布は、1変量分布で、対応する対数累積分布関数(cumulative distribution function: CDF)と対数相補累積分布関数(complementary cumulative distribution function: ccdf)があるものに限られています。切断分布とcdf、ccdfについてもっと知るには、26.3節の切断分布の項を参照してください。

### 9.2. 切断データ

切断データとは、ある下限より上か、上限より下か、あるいは上下限の間にある測定値しか報告されないようなデータです。

切断データはStanでは切断分布を使ってモデリングできるでしょう。例えば、切断データ$y_{n}$は、$y_{n}<300$となるように切断点$U=300$が上限となっているとします。Stanではこのデータは、観測値が切断正規分布に従うとして以下のようにモデリングできます。

```
data {
  int<lower=0> N;
  real U;
  real<upper=U> y[N];
}
parameters {
  real mu;
  real<lower=0> sigma;
}
model {
  for (n in 1:N)
    y[n] ~ normal(mu,sigma) T[,U];
}
```

このモデルでは、上限`U`をデータとして宣言し、この制約にあてはまるように`y`のデータに制約をつけています。これは、サンプリングが始まる前、データがモデルに読み込まれたときにチェックされます。

このモデルは、スケールと位置のパラメータに暗黙に非正則平坦事前分布を使っています。これらには、サンプリング文（~）を使って`model`ブロック中で事前分布を与えることもできます。

#### 制約と範囲外の値

切断分布では、サンプリングされた変量が切断の範囲外の値になったときには、確率は0になります。したがって対数確率は$-\infty$と評価されるでしょう。例えば、変量`y`が次の文でサンプリングされているとします。

```
for (n in 1:N)
  y[n] ~ normal(mu,sigma) T[L,U];
```

このとき、`y[n]`の値が`L`の値より小さいか、`U`の値よりも大きければ、サンプリング文は確率0の推定値を生成します。ユーザー定義の切断では、このように切断範囲外では0とするように明示的に処理しなければいけません。

変数が切断範囲外にそれるのを防ぐには、適切な制約が必要です。例えば、`y`が上のモデルのパラメータならば、`L`と`U`の値の間になるように宣言で制約をつけるべきです。

```
parameters {
  real<lower=L,upper=U> y[N];
  ...
```

上のモデルで、`L`と`U`がパラメータで`y`がデータなら、適切に制約をつけて、データがその間にあり、`L`の値が`U`の値よりも小さくなるようにしなくてはなりません（もし両者が等しければ、パラメータの範囲は1点にまで小さくなり、サンプラーで使われているハミルトニアン力学は破綻します）。以下の宣言は、境界がうまく設定されることを保証します。

```
parameters {
  real<upper=min(y)> L; // L < y[n]
  real<lower=fmax(L,max(y))> U; // L < U; y[n] < U
```

実数の組み合わせについては、`max`ではなく`fmax`関数を使うことに注意してください。

#### 未知の切断点

切断点が未知のときは、パラメータとして扱うことでこれを推定することができます。既知の切断点に関する前の節のモデルから、変数宣言を少し再構成することで、これが可能になります。

```
data {
  int<lower=1> N;
  real y[N];
}
parameters {
  real<upper = min(y)> L;
  real<lower = max(y)> U;
  real mu;
  real<lower=0> sigma;
}
model {
  L ~ ...;
  U ~ ...;
  for (n in 1:N)
    y[n] ~ normal(mu,sigma) T[L,U];
}
```

ここでは、下方の切断点`L`が、`y`の最小値以下と宣言されています。また、上方の切断点`U`は`y`の最大値以上と宣言されています。この宣言はデータに依存していますが、データが両切断点の間にあるという制約しか課していません。ただし、`N`が`int<lower=1>`という型で宣言されていますので、少なくとも1つのデータ点があるはずです。`L`が`U`よりも小さいという制約は、空ではないデータによって間接的に保証されるのです。

下限`L`と上限`U`の事前分布については省略していますが、このモデルにおいて`L`が`min(y)`のまわりに強く集中したり`U`が`max(y)`のまわりに強く集中したりしないように、情報のある事前分布を設定すべきでしょう。

### 9.3 打ち切りデータ

打ち切りデータとは、点の値が大きすぎたり、小さすぎたり、あるいはその両方の場合で、値が不明になるようなデータです。切断データと異なるのは、打ち切られたデータ点の数が分かっていることです。教科書に載っている例としては、135kgより重い値が報告されない家庭用の秤があります。

#### 打ち切りとなる値の推定

打ち切りデータをモデリングする方法の1つは、打ち切りデータを、打ち切られる範囲のあるという制約をつけた欠測データとして扱うことです。Stanでは配列や行列に未知の値を許しませんから、打ち切りとなる値は明示的に表さなくてはなりません。以下は、右側打ち切りの場合です。

```
data {
  int<lower=0> N_obs;
  int<lower=0> N_cens;
  real y_obs[N_obs];
  real<lower=max(y_obs)> U;
}
parameters {
  real<lower=U> y_cens[N_cens];
  real mu;
  real<lower=0> sigma;
}
model {
  y_obs ~ normal(mu,sigma);
  y_cens ~ normal(mu,sigma);
}
```

打ち切りデータの配列`y_cens`はパラメータとして宣言されていますので、位置とスケールのパラメータ、`mu`および`sigma`とともにサンプリングされます。打ち切りデータの配列`y_cens`は、`real<lower=U>`という型の値と宣言されていますので、打ち切りデータに補完される値はすべて`U`よりも大きくなります。打ち切りを補完したデータでは、モデル中の最後のサンプリング文を実行すると、位置とスケールのパラメータに影響が出ます。

#### 打ち切りとなる値の積分消去

位置とスケールを推定するときに打ち切りとなる値を無視するのは良くありませんが、補完値が必要な場合だけではありません。補完せずに、打ち切りとなる値を積分消去することもできます。打ち切られた各データ点は以下の確率を持ちます。

![$$\Pr[y>U]=\int_{U}^{\infty}\mathsf{Normal}(y \mid \mu, \sigma)dy = 1 - \Phi\left(\frac{y - \mu}{\sigma}\right)$$](fig/fig01.png)

ここで、$\Phi()$は標準正規分布の累積分布関数です。$M$個の打ち切り観測があるとき、合計の確率は対数軸で以下のようになります。

![$$\log\prod_{m=1}^{M}\Pr[y_{m}>U] = \log\left(1 - \Phi\left(\frac{y - \mu}{\sigma}\right)\right)^{M} = M \mathsf{normal\_ccdf\_log}(y, \mu, \sigma)$$](fig/fig02.png)

ここで、$\textsf{normal\_ccdf\_log}$は相補CDFの対数です（Stanに実装されている各分布には`<distr>_ccdf_log`があります）。

以下の右側打ち切りモデルでは、打ち切り点が既知であることを仮定しており、データとして宣言しています。

```
data {
  int<lower=0> N_obs;
  int<lower=0> N_cens;
  real y_obs[N_obs];
  real<lower=max(y_obs)> U;
}
parameters {
  real mu;
  real<lower=0> sigma;
}
model {
  y_obs ~ normal(mu,sigma);
  increment_log_prob(N_cens * normal_ccdf_log(U,mu,sigma));
}
```

`y_obs`の観測値については、打ち切りのない、正規分布のサンプリングを行なうモデルが使われています。打ち切りデータの項目については、正規分布の対数相補累積分布（訳注: 原文では'log cumulative normal probability'ですが、モデルにあわせて修正しました）の確率を計算して、それを対数確率に直接加算されています。

左側打ち切りデータでは、相補CDFの代わりにCDF(`normal_cdf_log`)を使わなくてはなりません。もし打ち切り点の変数(`L`)が未知なら、その宣言は`data`から`parameters`ブロックに移動すべきです。

```
data {
  int<lower=0> N_obs;
  int<lower=0> N_cens;
  real y_obs[N_obs];
}
parameters {
  real<upper=min(y_obs)> L;
  real mu;
  real<lower=0> sigma;
}
model {
  L ~ normal(mu,sigma);
  y_obs ~ normal(mu,sigma);
  increment_log_prob(N_cens * normal_cdf_log(L,mu,sigma));
}
````
## 3.データ型
本章ではStanで変数の宣言や、式の値に使われるデータ型について議論します。変数の型はパラメータの宣言、データの一貫性のチェック、関数の呼び出し、変数に値を代入する場合のすべてにおいて重要な要素となります。
Stanにおいて、すべての式と変数の宣言は、静的に定められたデータ型と関係しています（すなわちプログラムがコンパイルされた時）。一方、`vector`,`matrix`, `array`の大きさは動的に決定されます（プログラムが動作する際）。これは動的に変数に文字列を代入し、後から変数に行列を代入することができる、Rのような言語とは大きく異なっています。
式は変数、定数のような基礎要素、もしくは引数に適用される関数や演算子のような要素から構成されているでしょう。
本章では基本的なデータ型に話題を絞り、それらがどのように宣言、代入、使用されるかについて解説します。`array`, `vector`,`matrix`などのコンテナ型の詳細な比較については次章に譲ります。

### 3.1. 基本データ型
組み込み型関数やユーザ定義が定義した関数の引数、ローカル変数はいずれも基本データ型である必要があります。基本データ型とは、制約のない`primitive`型、`vector`型、`matrix`型、およびそれらを並べた`array`型のことです。

#### `primitive`型
Stanには連続値に対応したrealと、整数に対応したintの2種の`primitive`型が用意されています。

#### `vector`, `matrix`型
Stanには列ベクトルに対応した`vector`, 行ベクトルに対応した`row_vector`, 行列に対応した`matrix`の3種の行列ベースのデータ型が用意されています。

#### `array`型
array引数を宣言することで、任意の型（次節で紹介する制約付き型も含む）を`arra`y型とすることができます。以下に具体例を示します。

```
real x[10];
matrix[3,3] m[6,7];
```

上記のように記述すると、ｘは1次元で10個の実数が含まれた値として宣言することになります。mは同様に、3 × 3行列を6 × 7個並べた2次元`array`を宣言したことになります。

### 3.2. 制約付きデータ型
ローカル変数以外の変数を宣言する際には、制約をつけても構いません。この際、それぞれの制約付きデータ型は、制約付きの基本データ型と対応しています。
制約は`data`, `transformed data`, `transformed parameters`, `generated quantities`ブロックで宣言された変数のエラーをチェックします。
そのため、制約は、`parameters`ブロック内で宣言された変数を扱う際に重要になります。ここでは、`parameters`ブロックで、制約付き変数（宣言された制約を満たすもの）を制約のない変数（実数全体）にどのように変換するかを決めています。これは、
"モデルは宣言された制約を満たしているパラメータすべての値に対応 (密度がNon-zero)する必要がある"
という、制約付きデータ型の最も重要な側面を示しています。

もし宣言されたパラメータの制約が対応よりも厳格でない場合、サンプラーやオプティマイザはさまざまな問題を抱えることになるでしょう。このような例として、プログラムが動作しない、初期化の失敗、過剰なMetropolis rejection、分布の裾をサンプリングできないことに起因するサンプリングのバイアスなどが問題として挙げられます。

#### 上限、下限の設定
以下のようにすべての基本データ型に制約を宣言する構文を使うことで、変数の上限、下限を与えることができます。

```
int<lower=1> N;
real<upper=0> log_p;
vector<lower=-1,upper=1>[3,3] corr;
```

#### 構造化ベクトル
Stanには構造化された`vector`を扱うためのデータ型が用意されています。昇順で並べた値の`vector`に使われる`ordered`と、昇順に並べた正の値の`vector`について使われる`positive_ordered`がそれにあたります。
また、合計すると1になる非負の値のベクトルに対するデータ型として`simplex`が、 2乗の合計が1になるベクトルに対するデータ型として`unit_vector`が用意されています。　　

#### 構造化マトリクス
対称な正定値行列を表すために、`cov_matrix`が、対角成分が1である対称な正定値行列、すなわち相関行列を表すために、`corr_matrix`が用意されています。
また、コレスキー因子の型も用意されています。`cholesky_factor_cov`型は対称な正定値行列のコレスキー因子、すなわち正の対角成分を持つ下三角行列を表します。`cholesky_factor_corr`型は相関行列のコレスキー因子、すなわち正の対角成分を持つ下三角行列で、さらに各々の行が単位ベクトル（つまり2乗して合計すると1）であるような下三角行列を表すために使用できます。因子分解、スケーリングが容易なコレスキー因子型を使うことで、すべての相関行列、分散共分散行列を計算するよりもはるかに効率よく計算を行うことができます。

### 3.3. 代入・引数の受け渡し
#### 代入
 制約付けられたデータの値は基本型にマッチする制約付けられていない変数に代入されるかもしれないし、その逆の、制約付けられていないデータの値が基本型にマッチする制約付けられた変数に代入されることもあるかもしれません。マッチングに際しては`array`の次元数、基本型が同じであるか、厳密に解釈されます。制約付けは考慮されませんが、基本データ型については考慮されます。
`array`, `vector`はお互いに代入することはできません。同様に、たとえ次元が一致していても、`vector`, `matrix`はお互いに代入することはできません。第4章では`vector`, `array`をどのように使い分けるのが適切かについて、詳細を示します。

#### 関数の呼び出し
Stanの関数に引数を渡すと、基本型への代入のように動作します。Stanの関数は`array`の次元（`real` a[10,10,10]なら3）を含む、引数の基本データ型だけからどの関数が呼ばれるかが決まります（`array`の大きさ、制約は含まない）。もちろん、関数はしばしばそれらの動作の一部として制約を確認することがあります。

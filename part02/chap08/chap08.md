## 8. 欠測データと部分的に既知のパラメータ

ベイズ推定では欠測データに対してごく一般的な手法を使えます。すなわち、欠測データの項目すべてが、事後分布で推定されるパラメータとして表されます(Gelman et al., 2013)。欠測データが明示的にモデル化されないのであれば、たいていの回帰モデルの予測変数でそうですが、結果は、欠測している予測変数を表すパラメータに非正則事前分布を設定することになります。

観測データと欠測データを配列に混ぜる方法はStanに取り入れるのは難しいことがあります。これは一部には、離散の未知量をモデル化する方法がStanではトリッキーなことがあることによりますし、また一部には、ほかのいくつかの統計言語（例えば、RやBUGS）とは違ってStanでは、観測量と未知量はモデル中の別の場所で定義する必要があることによります。そのため、Stanプログラムでは、データ構造中にある観測部分と欠測部分とを組み合わせて一緒にするコードを含める必要がある場合があります。例はこの章でこの後から紹介します。

### 8.1. 欠測データ

Stanでは、`data`と`transformed data`ブロックで宣言された変数を既知量として、`parameters`ブロックで宣言された変数を未知量として扱います。

正規分布に従う観測値に欠測データを含む例<sup>1</sup>は以下のようにコーディングできるでしょう。

```
data {
  int<lower=0> N_obs;
  int<lower=0> N_mis;
  real y_obs[N_obs];
}
parameters {
  real mu;
  real<lower=0> sigma;
  real y_mis[N_mis];
}
model {
  for (n in 1:N_obs)
    y_obs[n] ~ normal(mu,sigma);
  for (n in 1:N_mis)
    y_mis[n] ~ normal(mu,sigma);
}
```

観測データ点と欠測データ点の数は、非負の整数の変数`N_obs`と`N_mis`にデータとしてコーディングされています。観測データは、`array`型のデータの変数`y_obs`として与えられています。欠測データは`array`型のパラメータ`y_mis`としてコーディングされています。通常のパラメータは推定されるので、位置`mu`とスケール`sigma`もパラメータとしてコーディングされています。このモデルをもっとうまく書く方法はベクトル化することです。そうすると本体は次のようになります。

```
  y_obs ~ normal(mu,sigma);
  y_mis ~ normal(mu,sigma);
```

このモデルには、観測データと欠測データにそれぞれ1つのループがあります。これはモデル指定としていささか冗長ですが、そのおかげで、Stanでの欠測データ問題としては、次の節で記述するもっと一般的なテクニックよりもはるかに効率的なサンプリングが可能になります。

<sup>1</sup>もっと意味のある推定の例は、予測変数を使った観測された観測値と欠測の観測値の回帰を含むものでしょう。観測された観測値に対応する予測変数も欠測の観測値に対応する予測変数も既知で、`data`ブロックで指定されているものです。

### 8.2. 部分的に既知のパラメータ

多変量の確率関数で、一部の結果やパラメータだけが観測されているといったような状況では、既知量（データ）と未知量（パラメータ）とを混ぜたベクトルを作る必要があります。Stanでこれをおこなうのは、`transformed parameters`ブロックでベクトルあるいは配列をつくり、それに代入することで可能です。

以下の例は、2変数の共分散行列を含むもので、分散は既知ですが、共分散は既知ではありません。

```
data {
  int<lower=0> N;
  vector[2] y[N];
  real<lower=0> var1;     real<lower=0> var2;
}
transformed data {
  real<upper=0> min_cov;
  real<lower=0> max_cov;
  max_cov <- sqrt(var1 * var2);
  min_cov <- -max_cov;
}
parameters {
  vector[2] mu;
  real<lower=min_cov,upper=max_cov> cov;
}
transformed parameters {
  matrix[2,2] sigma;
  sigma[1,1] <- var1;     sigma[1,2] <- cov;
  sigma[2,1] <- cov;      sigma[2,2] <- var2;
}
model {
  for (n in 1:N)
    y[n] ~ multi_normal(mu,sigma);
}
```

分散は、変数`var1`および`var2`にデータとして定義されていますが、共分散は、変数`cov`にパラメータとして定義されています。2×2共分散行列`sigma`は変換パラメータ(transformed parameter)として定義されています。分散は、2つの対角要素に代入され、共分散は、2つの非対角要素に代入されます。

共分散の宣言につけた制約により、結果の共分散行列`sigma`が正定値であることが保証されます。分散の積の、正負の平方根が上下限となりますが、この値は`transformed data`として定義されるので、計算されるのは1回だけです。

### 8.3. 効率性についての注意

はじめの節の欠測データの例は、次の節の、部分的に既知のパラメータの例の方法と同じように、データとパラメータとを混ぜた配列としてプログラミングすることもできるでしょう。正しく動くでしょうが、計算には無駄が多くなります。`parameters`あるいは`transformed parameters`ブロックで宣言される各パラメータは自動微分の変数を使います。単純なデータの変数と比較すると、記憶容量と勾配計算の時間の点でこれはより高くつきます。さらに、そのコピーが余分な容量と余分な時間を使います。

### 8.4. 因子分析の負荷行列

Rick Farouniは、Stan users groupで、単位対角の共分散行列についてCholesky因子をつくる方法を尋ねました。これは、ベイズ因子分析(Aguilar and West 2000)で使われます。対角下の要素をパラメータとして宣言し、それから変換パラメータ(tranformed parameter)とした行列全体に値を埋めることで、これを行なうことができます。

```
data {
  int<lower=2> K;
}
transformed data {
  int<lower=1> K_choose_2;
  K_choose_2 <- (K * (K - 1)) / 2;
}
parameters {
  vector[K_choose_2] L_lower;
}
transformed parameters {
  cholesky_factor_cov[K] L;
  for (k in 1:K)
    L[k,k] <- 1;
  {
    int i;
    for (m in 2:K) {
      for (n in 1:(m - 1)) {
        L[m,n] <- L_lower[i];
        L[n,m] <- 0;
        i <- i + 1;
      }
    }
  }
}
```

事前分布は、`L_lower`に直接置くのが最も便利です。もうひとつの方法は、Cholesky因子`L`全体への事前分布でしょう。`L_lower`から`L`への変換では値は変わらないので、（訳注: 確率変数の変換に伴う）ヤコビアンの調整を必要としないからです（必要としないにもかかわらず、パーサから警告が出ます。これはパーサがコード解析をして変換が線形であると推測するほど十分に賢くないためです。）。共分散行列`L * L'`全体に事前分布を置くのは、Jacobian調整が必要となるでしょうから、まったく便利ではないでしょう。正確な調整は、共分散行列を扱う56.1節の小節で示します。

## 5. multiple indexingとrange indexing
Stanはコンテナ（すなわち配列・`vector`・`matrix`）に対して、整数値のインデックスの配列または範囲のインデックスを使うことで、複数のインデックスによるアクセスを一度に行うことができます。以降ではこの機能を「multiple indexing」と呼びます。この機能を使うと多くのモデルをベクトル化できます。例えば、傾きと切片が個体によって異なる階層線形回帰モデルの尤度を考えてみましょう。Stanのコードは以下になるでしょう。

```
for (n in 1:N)
  y[n] ~ normal(alpha[ii[n]] + beta[ii[n]] * x[n], sigma);
```

multiple indexingを使うと、このコードは1行になり、より効率的なベクトル化されたコードになります。

```
y ~ normal(alpha[ii] + beta[ii] .* x, sigma);
```

後者のバージョンはローカル変数に代入するダサい方法とスピード面では等価です。

```
{
  vector[N] mu;
  for (n in 1:N)
  mu[n] = alpha[ii[n]] + beta[ii[n]] * x[n];
  y ~ normal(mu, sigma);
}
```

### 5.1. Multiple Indexing
整数値の配列を使ったmultiple indexingの最も単純な具体例は以下です。省略（...）はコメントにあるように変数を定義するコードを表します。

```
int c[3];
... // 定義: c == (5, 9, 7)
int idxs[4];
... // 定義: idxs == (3, 3, 1, 2)
int d[4];
d = c[idxs]; // 結果: d == (7, 7, 5, 9)
```

一般的にはmultiple indexを表現した`c[idxs]`は、`idxs`を大きさ`K`の配列として、以下のように定義されます。

```
c[idxs] = ( c[idxs[1]], c[idxs[2]], ..., c[idxs[K]] )
```

このように`c[idxs]`は`idxs`と同じ大きさになります。この例では大きさは`K`です。multiple indexingは多次元配列にも使うことができます。例えば、以下を考えましょう。

```
int c[2, 3];
... // 定義: c = ((1, 3, 5), ((7, 11, 13))
int idxs[4];
... // 定義: idxs = (2, 2, 1, 2)
int d[4, 3]
d = c[idxs]; // 結果: d = ((7, 11, 13), (7, 11, 13),
             //              (1, 3, 5), (7, 11, 13))
```

すなわち、`c[idxs]`のようにインデックスを1番目の位置に置くと、`idxs`が1次元配列の場合に定義したのと全く同じように振る舞います。つまり、インデックスの指す値自体が配列になっているだけで、結果はやはり`c[idxs][j] == c[idxs[j]]`として定義されます。

multiple indexingは多次元配列の2番目の位置で使うこともできるでしょう。上の例の続きとして、1番目の位置にsingle indexで2番目の位置にmultiple indexを使う場合を考えましょう。

```
int e[4];
e = c[2, idxs]; // 結果: c[2] = (7, 11, 13)
                // 結果: e = (11, 11, 7, 11)
```

1番目の位置にsingle indexを使うと、1次元の結果となります。そして、その結果に対してmultiple indexが適用されます。すなわち、`c[2,idxs]`は`c[2][idxs]`と同じものとして評価されます。

multiple indexingは多次元配列の1つ以上の位置に対して適用できます。例えば、以下を考えましょう。

```
int c[2, 3];
... // 定義: c = ((1, 3, 5), (7, 11, 13))
int idxs1[3];
... // 定義: idxs1 = (2, 2, 1)
int idxs2[2];
... // 定義: idxs2 = (1, 3)
int d[3, 2];
d = c[idxs1, idxs2]; // 結果: d = ((7, 13), (7, 13), (1, 5))
```

multiple indexを複数の位置で使うと、もはや`c[idxs1, idxs2]`は`c[idxs1][idxs2]`と同じではなくなります。上のコードを実行したあとの`d[i, j]`の要素は以下で与えられるのです。

```
d[i, j] == c[idxs1, idxs2][i, j] = c[idxs1[i], idxs2[j]]
```

この例は一般的な場合においてmultiple indexingの動作を示したものです。`idxs1`のようなmultiple indexは、結果（ここでは`c[idxs1, idxs2]`）に対するインデックス`i`を、アクセスの対象となる変数（ここでは`c`）におけるインデックス`idxs1[i]`に変換します。対照的に、single indexはそのインデックスにおける値を単に返します。そして変数の次元が1つ減った結果となります。


### 5.2. range indexを使ったアクセス（slicing）
range indexを使ったアクセス（以降ではslicingと呼びます）は、1次元配列の連続したスライスや2次元配列の連続した部分ブロックなどを返します。意味的にはslicingはmultiple indexingの特殊な場合にすぎません。

#### 上下限を与えるインデックス
例えば、インデックスに上限と下限を与える場合を考えましょう。

```
int c[7];
...
int d[4];
d = c[3:6]; // 結果: d == (c[3], c[4], c[5], c[6])
```

range indexである`3:6`は意味的にはmultiple indexの`(3, 4, 5, 6)`と同じように振る舞います。実装の観点からはrange indexの方が高速かつ省メモリです。なぜなら、range indexはmultiple indexを陽に作っているわけではなく、むしろ直接的なループを使っているからです。さらにrange indexは読みやすいので、もし適用できるならばmultiple
indexよりも好んで使うべきです。

#### 下限か上限を与えるインデックス
下限だけ、上限だけ与えることも可能です。`c[3:]`は`c[3:size(c)]`を略したものです。`c[:5]`は`c[1:5]`を略したものです。

#### 範囲全体のインデックス
最後に、配列のすべての範囲をカバーするrange indexを書くこともできます。それは単にrangeの記号（:）をインデックスとして書くか、そのインデックスの位置を空にすることで実現できます。両方の場合において、`c[]`と`c[:]`は`c[1:size(c)]`と同じであり、それはすなわち単に`c`と同じになります。


### 5.3. 代入文の左辺でmultiple indexingを使う
multiple indexingは代入文の左辺で使うこともできるでしょう。そこでは、右辺でコンテナの要素を抽出するときとまったく同じ方法で動きます。例えば、以下を考えましょう。

```
int a[3];
int c[2];
int idxs[2];
...          // 定義: a == (1, 2, 3); c == (5, 9)
             //        idxs = (3,2)
a[idxs] = c; // 結果: a == (1, 9, 5)
```

上のコードの代入文の結果は次のようになります。`a[idxs[1]]`（すなわち`a[3]`）には`c[1]`（すなわち`5`）が代入され、`a[idxs[2]]`（すなわち`a[2]`）には`c[2]`（すなわち`9`）が代入されます。

multiple indexが多数あるときには、同じルールが以下のように適用されます。

```
int a[5, 7];
int c[2, 2];
...
a[2:3, 5:6] = c;  // 結果: a[2, 5] == c[1, 1]; a[2, 6] == c[1, 2]
                  //       a[3, 5] == c[2, 1]; a[3, 6] == c[2, 2]
```

1次元の場合と同じように、左辺でスライスやブロックもしくは何らかのかたまりを指定し、右辺がそこへ書き込まれます。

左辺でmultiple indexを使用して再配置やslicingをする際にも、一般的にsingle indexは次元を減らし、multiple indexは次元を保ちます。例えば、以下のように2次元配列の行の一部分に代入することもできます。

```
int a[10, 13];
int c[2];
...
a[4, 2:3] = c;  // 結果: a[4, 2] == c[1]; a[4, 3] == c[2]
```

#### 値ごとの代入とaliasing
代入の左辺と右辺で同じデータ構造を参照している際に、aliasingと呼ばれる問題が起きます。例えば、以下のコードにおける配列`a`を考えましょう。

```
int a[3];
... // 定義: a == (5, 6, 7)
a[2:3] = a[1:2];
... // 結果: a == (5, 5, 6)
```

代入のあとに`a`の値が`(5, 5, 5)`ではなく`(5, 5, 6)`になる理由は、Stanでは右辺の式が新しくコピーされるかのように振る舞うからです。もう一つの例として以下を考えましょう。

```
int a[3];
int idxs[3];
... // 定義 idxs = (2, 1, 3)
a[idxs] = a;
```

この場合、代入の前にコピーが右辺の必要なのは明らかです。`a[2:3] = a[1:2]`という代入では以下の一連の代入を実行するのと同じと思ってしまいがちです（それは間違いです）。

```
... // 定義: a = (5, 6, 7)
a[2] = a[1]; // 結果: a = (5, 5, 7)
a[3] = a[2]; // 結果: a = (5, 5, 5)!
```

これは違う結果を生みます。なぜなら`a[2]`の値が使う前に変わっているからです。

### 5.4. `vector`や`matrix`に対するmultiple index

mulitple indexは`vector`や`matrix`にも使うことができますし、同じように`vector`や`matrix`の配列にも使うことができます。

#### `vector`の場合
multiple indexを使う場合、`vector`と`row_vector`は配列とまったく同じように振る舞います。もし`v`が`vector`ならば`v[3]`はスカラーの実数値になる一方で、`v[2:4]`は要素`v[2]`,`v[3]`,`v[4]`を含む長さ3の`vector`になります。

唯一少し違う点は、multiple indexを使った場合にどのような型を返すかの型推論が異なります。例えば、以下の最小の例を考えましょう。

```
vector[5] v[3];
int idxs[7];
...
vector[7] u;
u = v[2, idxs];

real w[7];
w = v[idxs, 2];
```

ポイントはsingle indexは常に次元を減らすのに対し、multiple indexは決して次元を減らさないことです。multiple indexを使った次元（とインデックスを使っていない次元）がインデックスされた式の型を決めます。上の例では`v`が`vector`の配列なので、`v[2, idxs]`は配列の次元を減らすけれども、`vector`の次元を減らしません（スカラーになりません）。そして、`w`の型は`real`の配列になります。両方の場合において、multiple indexの大きさ（ここでは`7`）が結果の大きさを決めています。

#### `matrix`の場合

`matrix`の場合はもう少しトリッキーです。なぜなら`matrix`は2つの次元を持つからです。しかし、背後にある型推論のルールは同じです。multiple indexは次元を減らさないけれども、single indexは次元を減らすというルールです。以下のコードは`matrix`に対するmultiple indexingがどのように動くか示します。

```
matrix[5,7] m;
...
row_vector[3] rv;
rv = m[4, 3:5];    // 結果は 1 x 3
...
vector[4] v;
v = m[2:5, 3];     // 結果は 3 x 1
...
matrix[3, 4] m2;
m2 = m[1:3, 2:5];  // 結果は 3 x 4
```

ポイントはどの位置にmultiple indexやrange indexを使っても結果に反映されている一方で、single indexを使うと1次元になることです。上のコードのコメントで示唆した結果の次元から、結果の型を読み取ることができるでしょう。

#### `matrix`に1つのmultiple indexを使う

もし`matrix`が1つのmultiple indexを受け取ると、結果は`matrix`になります。したがってもし`m`が`matrix`なら`m[2:4]`は`matrix`です。対照的に、`m[3]`のようにsingle indexを与えると結果は`row_vector`になります。すなわち、`m[3]`は`m[3, ]`や`m[3, 1:cols(m)]`と同じ結果になります。

#### `vector`や`matrix`の配列
`matrix`や`vector`や`row_vector`の配列の場合も、基本的なルールはまったく同じままです。例えば、以下の例を考えましょう。

```
matrix[3, 4] m[5, 7];
...
matrix[3, 4] a[2];
a = m[1, 2:3];  // 1番目の配列の次元を減らす
a = m[3:4, 5];  // 2番目の配列の次元を減らす
```

両方の代入において、multiple indexは配列の次元を減らしています。しかし、結果は異なります。1番目のケースでは`a[i] == m[1, i + 1]`となる一方、2番目のケースでは`a[i] == m[i + 2, 5]`となります。

前の例に続けて以下を考えましょう（訳注：以降5.5節まで原文では`a`でしたが`m`に変更しました）。

```
...
vector[2] b;
b = m[1, 3, 2:3, 2];
```

ここでは2つの配列の次元が減って、`matrix`の列の次元も減り、行の次元だけ残るので、結果は`vector`になります。この場合では、`b[j]
== m[1, 3, 1 + j, 2]`です。

この最後の例は大切なポイントを表しています。もし、下限`2`が与えらえた`2:3`のように下限のあるインデックスがあると、上の例で`1 + j`という式で見られるように下限引く1である`1`がインデックス`j`に加わります。

さらに続けて、次を考えましょう。

```
...
row_vector[3] c[2];
c = m[4:5, 3, 1, 2: ];
```

ここでは2番目の配列の次元が減って1次元配列となり、`matrix`の行のインデックスが減って`row_vector`となっています。インデックスによるアクセスの結果、値は`c[i, j] == a[i + 3, 3, 1, j + 1]`となります。


### 5.5. パラメータと固定値を含んだ`matrix`
3行3列の`matrix`があって、2つの要素がゼロで残りの要素がパラメータである場合を考えてみましょう。そのような状況は固定されたパラメータを伴う問題や欠測データがある場合に起こります。

ある3行3列の`matrix`が`[1, 2]`と`[1, 3]`の要素はゼロだと知られているとしましょう。この場合、パラメータに対するインデックスは「融けた」データフレームやデータベースのフォーマットで表されます。

```
transformed data {
  int<lower=1, upper=3> ii[7];
  int<lower=1, upper=3> jj[7];
  ii[1] = 1; jj[1] = 1;
  ii[2] = 2; jj[2] = 1; 　// [1, 2] と [1, 3] を飛ばす
  ii[3] = 3; jj[3] = 1;
  ii[4] = 2; jj[4] = 2;
  ii[5] = 3; jj[5] = 2;
  ii[6] = 2; jj[6] = 3;
  ii[7] = 3; jj[7] = 3;
}
```

7つの残っているパラメータは`vector`として宣言されます。

```
parameters {
  vector[7] A_raw;
}
```

そして、フル行列`A`は`model`ブロックにおいてローカル変数として構築されます。

```
model {
  matrix[3, 3] A;
  A[ii, jj] = A_raw;
  A[1, 2] = 0;
  A[1, 3] = 0;
}
```

この状況ではこの方法はやりすぎに見えるかもしれません。しかし、より一般的な状況では、固定値の要素を埋めるために`matrix`のサイズ・`vector`の長さ・配列`ii`と`jj`や大きさを、固定値の値とともにデータとしてコードに書くことになるでしょう。一握りの要素が正だとわかっている場合など、アドホックな制約がある`matrix`を構築するには、似たテクニックが使われるでしょう。
